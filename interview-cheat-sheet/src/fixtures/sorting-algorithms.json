[
  {
    "name": "Heap",
    "description": "Uses a binary heap to extract the maximum (or minimum) element and place it in the sorted array.",
    "time": {
      "best": "Ω(n log(n))",
      "average": "Θ(n log(n))",
      "worst": "O(n log(n))"
    },
    "space": { "worst": "O(1)" }
  },
  {
    "name": "Merge",
    "description": "Divides the array, recursively sorts halves, and merges them.",
    "time": {
      "best": "Ω(n log(n))",
      "average": "Θ(n log(n))",
      "worst": "O(n log(n))"
    },
    "space": { "worst": "O(n)" }
  },
  {
    "name": "Quick",
    "description": "Chooses a pivot, partitions the array, and recursively sorts partitions.",
    "time": {
      "best": "Ω(n log(n))",
      "average": "Θ(n log(n))",
      "worst": "O(n^2)"
    },
    "space": { "worst": "O(log(n))" }
  },
  {
    "name": "Tree",
    "description": "A sorting algorithm that builds a binary search tree from the elements to be sorted, then traverses the tree to retrieve the elements in sorted order.",
    "time": {
      "best": "Ω(n log(n))",
      "average": "Θ(n log(n))",
      "worst": "O(n^2)"
    },
    "space": { "worst": "O(n)" }
  },
  {
    "name": "Comb",
    "description": "Improves upon bubble sort by using a gap sequence to eliminate turtles, or small values near the end of the list, which slows down the sorting process in bubble sort.",
    "time": { "best": "Ω(n log(n))", "average": "Θ(n^2)", "worst": "O(n^2)" },
    "space": { "worst": "O(1)" }
  },
  {
    "name": "Shell",
    "description": "Extension of insertion sort that allows the exchange of items that are far apart. It starts by sorting pairs of elements far apart from each other, then progressively reduces the gap between elements to be compared.",
    "time": {
      "best": "Ω(n log(n))",
      "average": "Θ((n log(n))^2)",
      "worst": "O(n(log(n))^2)"
    },
    "space": { "worst": "O(1)" }
  },
  {
    "name": "Cube",
    "description": "Operates by recursively dividing the array into sub-cubes, sorting each cube individually, and then merging them back together, offering a balance between time complexity and space complexity.",
    "time": {
      "best": "Ω(n)",
      "average": "Θ(n log(n))",
      "worst": "O(n log(n))"
    },
    "space": { "worst": "O(n)" }
  },
  {
    "name": "Tim",
    "description": "A hybrid sorting algorithm derived from merge sort and insertion sort, designed to perform well on real-world data and exploit existing order in the input sequence.",
    "time": {
      "best": "Ω(n)",
      "average": "Θ(n log(n))",
      "worst": "O(n log(n))"
    },
    "space": { "worst": "O(n)" }
  },
  {
    "name": "Bubble",
    "description": "Repeatedly compares adjacent elements and swaps them if they are in the wrong order.",
    "time": { "best": "Ω(n)", "average": "Θ(n^2)", "worst": "O(n^2)" },
    "space": { "worst": "O(1)" }
  },
  {
    "name": "Insertion",
    "description": "Builds the final sorted array one element at a time by inserting each element into its position.",
    "time": { "best": "Ω(n)", "average": "Θ(n^2)", "worst": "O(n^2)" },
    "space": { "worst": "O(1)" }
  },
  {
    "name": "Selection",
    "description": "Finds the smallest (or largest) element and places it at the beginning (or end) of the array.",
    "time": { "best": "Ω(n^2)", "average": "Θ(n^2)", "worst": "O(n^2)" },
    "space": { "worst": "O(1)" }
  },
  {
    "name": "Bucket",
    "description": "Divides the input array into a number of buckets, each of which is then sorted individually, typically with another sorting algorithm or by recursively applying bucket sort.",
    "time": { "best": "Ω(n + k)", "average": "Θ(n + k)", "worst": "O(n^2)" },
    "space": { "worst": "O(n)" }
  },
  {
    "name": "Counting",
    "description": "An integer sorting algorithm that works by determining the number of objects having distinct key values and using arithmetic to determine their position in the output array.",
    "time": { "best": "Ω(n + k)", "average": "Θ(n + k)", "worst": "O(n + k)" },
    "space": { "worst": "O(k)" }
  },
  {
    "name": "Radix",
    "description": "Sorts based on individual digits or characters, from least to most significant.",
    "time": { "best": "Ω(nk)", "average": "Θ(nk)", "worst": "O(nk)" },
    "space": { "worst": "O(n + k)" }
  }
]
